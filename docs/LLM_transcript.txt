## Student Name: Muhammad Ibrahim
## Student ID: 218849240

Prompt 1: "Explain to me what solutions.py has right now in 
the context of this project, and what is required for me to complete the 
missing functionality. How may I go about completing it?"
LLM Response 1: "Purpose:
The file is a stub for the function is_allocation_feasible, which determines if a set of resource requests can be satisfied given limited resource capacities.

Contents:

Imports: Dict, List, Union from typing for type hints.
Defines Number as Union[int, float] for flexibility in resource values.
The function is_allocation_feasible is defined with docstrings explaining its purpose and arguments.
The function currently raises NotImplementedError, meaning it does not perform any logic yet.
What Is Required
You need to implement the logic for is_allocation_feasible. Specifically:

Inputs:

resources: a dictionary mapping resource names to their total available capacity.
requests: a list of dictionaries, each representing a request for resources (resource name → amount required).
Output:

Return True if all requests can be satisfied without exceeding any resource's capacity.
Return False otherwise.
How to Complete It
Aggregate Requests:
For each resource, sum up the total amount requested across all requests.

Compare to Available Capacity:
For each resource, check if the total requested amount is less than or equal to the available capacity.

Return Result:

If all resources can satisfy the requests, return True.
If any resource is over-requested, return False."

--------------------------------------------------
Prompt 2: "Is my current implementation of the code correct?"
LLM Response 2: "Your current implementation mostly works, but it has a significant issue:

Problem
You are modifying the resources dictionary in-place as you subtract amounts for each request. This means:

If the function is called multiple times, the original resources dictionary will be changed, which can lead to unexpected behavior elsewhere in your code.
Modifying input arguments is generally discouraged unless explicitly intended.
Other Considerations
You correctly check if each request is a dictionary.
You return False if a resource is requested that does not exist.
You return False if any resource is over-allocated.
Recommendation
Fix:
Work on a copy of the resources dictionary to avoid side effects."
--------------------------------------------------

Prompt 3: "how can I run the pytest code from the command line using the one I have already isntalled?"
LLM Response 3: "You already have pytest installed, but you must run it the same way it was installed and not run the test file directly.

Below is the correct, minimal way to run pytest with what you already have.

✅ The ONE correct command you should use

From the project root:

/bin/python3.11 -m pytest


Or if you want just that file:

/bin/python3.11 -m pytest src/test_solution.py


That’s it."

Prompt 4: "What are the test cases capturing right now, and what are some areas the testing is missing?"
LLM Response 4: "What the Current Test Cases Capture
Basic Feasible Single Resource

Checks if the function returns True when the total demand for a single resource does not exceed its capacity.
Multi-Resource Infeasible (One Overloaded)

Checks if the function returns False when one of multiple resources is over-requested.
Missing Resource in Availability

Checks if the function returns False when a request asks for a resource not present in the available resources.
Non-Dict Request Raises Error

Checks if the function raises a ValueError when a request is not a dictionary.

Areas Missing in Testing
Zero Requests

What happens if the requests list is empty? (Should return True.)
Zero Resources

What if the resources dictionary is empty? (Should only be feasible if there are no requests.)
Requests with Zero Amounts

Requests that ask for zero of a resource (should not affect feasibility).
Negative Resource Amounts

Requests or resources with negative values (should be handled or rejected).
Floating Point Resources

Use of floats instead of integers for resources and requests.
Multiple Requests for the Same Resource

Ensures cumulative requests are handled correctly.
Resource Not Requested

Resources available but not requested at all.
Large Number of Requests

Stress test with many requests to check performance and correctness."

Prompt 5: "Help me create 5 additional test cases to test the missed areas"
LLM Response 3: "def test_empty_requests():
    # No requests should always be feasible
    resources = {'cpu': 5, 'mem': 10}
    requests = []
    assert is_allocation_feasible(resources, requests) is True

def test_empty_resources_with_requests():
    # No resources but requests present should be infeasible
    resources = {}
    requests = [{'cpu': 1}]
    assert is_allocation_feasible(resources, requests) is False

def test_zero_amount_requests():
    # Requests for zero resources should not affect feasibility
    resources = {'cpu': 2}
    requests = [{'cpu': 0}, {'cpu': 0}]
    assert is_allocation_feasible(resources, requests) is True

def test_negative_request_amount():
    # Negative request amounts should be handled (here, treat as infeasible)
    resources = {'cpu': 5}
    requests = [{'cpu': -1}]
    assert is_allocation_feasible(resources, requests) is True  # Acceptable if negative means "give back"

def test_float_resource_and_request():
    # Test with float values for resources and requests
    resources = {'cpu': 5.5}
    requests = [{'cpu': 2.2}, {'cpu': 3.3}]
    assert is_allocation_feasible(resources, requests) is True"

Prompt 6: "Which edge cases are still missing from the testing"
LLM Response 6: "Here are some edge cases still missing from your current tests:

Request for a resource with amount exactly equal to capacity

Ensures allocation is feasible when demand matches capacity exactly.
Multiple resources, some not requested at all

Checks that unused resources do not affect feasibility.
Request with extra keys (resources) not in the available resources

Already partially tested, but could be more explicit for multiple unknown resources.
Large number of requests (stress test)

Checks performance and correctness with many requests."
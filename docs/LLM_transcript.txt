## Student Name: Muhammad Ibrahim
## Student ID: 218849240

Prompt 1: "Explain to me what solutions.py has right now in 
the context of this project, and what is required for me to complete the 
missing functionality. How may I go about completing it?"
LLM Response 1: "Purpose:
The file is a stub for the function is_allocation_feasible, which determines if a set of resource requests can be satisfied given limited resource capacities.

Contents:

Imports: Dict, List, Union from typing for type hints.
Defines Number as Union[int, float] for flexibility in resource values.
The function is_allocation_feasible is defined with docstrings explaining its purpose and arguments.
The function currently raises NotImplementedError, meaning it does not perform any logic yet.
What Is Required
You need to implement the logic for is_allocation_feasible. Specifically:

Inputs:

resources: a dictionary mapping resource names to their total available capacity.
requests: a list of dictionaries, each representing a request for resources (resource name → amount required).
Output:

Return True if all requests can be satisfied without exceeding any resource's capacity.
Return False otherwise.
How to Complete It
Aggregate Requests:
For each resource, sum up the total amount requested across all requests.

Compare to Available Capacity:
For each resource, check if the total requested amount is less than or equal to the available capacity.

Return Result:

If all resources can satisfy the requests, return True.
If any resource is over-requested, return False."

--------------------------------------------------
Prompt 2: "Is my current implementation of the code correct?"
LLM Response 2: "Your current implementation mostly works, but it has a significant issue:

Problem
You are modifying the resources dictionary in-place as you subtract amounts for each request. This means:

If the function is called multiple times, the original resources dictionary will be changed, which can lead to unexpected behavior elsewhere in your code.
Modifying input arguments is generally discouraged unless explicitly intended.
Other Considerations
You correctly check if each request is a dictionary.
You return False if a resource is requested that does not exist.
You return False if any resource is over-allocated.
Recommendation
Fix:
Work on a copy of the resources dictionary to avoid side effects."
--------------------------------------------------

Prompt 3: "how can I run the pytest code from the command line using the one I have already isntalled?"
LLM Response 3: "You already have pytest installed, but you must run it the same way it was installed and not run the test file directly.

Below is the correct, minimal way to run pytest with what you already have.

✅ The ONE correct command you should use

From the project root:

/bin/python3.11 -m pytest


Or if you want just that file:

/bin/python3.11 -m pytest src/test_solution.py


That’s it."

Prompt 4: "What are the test cases capturing right now, and what are some areas the testing is missing?"
LLM Response 4: "What the Current Test Cases Capture
Basic Feasible Single Resource

Checks if the function returns True when the total demand for a single resource does not exceed its capacity.
Multi-Resource Infeasible (One Overloaded)

Checks if the function returns False when one of multiple resources is over-requested.
Missing Resource in Availability

Checks if the function returns False when a request asks for a resource not present in the available resources.
Non-Dict Request Raises Error

Checks if the function raises a ValueError when a request is not a dictionary.

Areas Missing in Testing
Zero Requests

What happens if the requests list is empty? (Should return True.)
Zero Resources

What if the resources dictionary is empty? (Should only be feasible if there are no requests.)
Requests with Zero Amounts

Requests that ask for zero of a resource (should not affect feasibility).
Negative Resource Amounts

Requests or resources with negative values (should be handled or rejected).
Floating Point Resources

Use of floats instead of integers for resources and requests.
Multiple Requests for the Same Resource

Ensures cumulative requests are handled correctly.
Resource Not Requested

Resources available but not requested at all.
Large Number of Requests

Stress test with many requests to check performance and correctness."

Prompt 5: "Help me create 5 additional test cases to test the missed areas"
LLM Response 3: "def test_empty_requests():
    # No requests should always be feasible
    resources = {'cpu': 5, 'mem': 10}
    requests = []
    assert is_allocation_feasible(resources, requests) is True

def test_empty_resources_with_requests():
    # No resources but requests present should be infeasible
    resources = {}
    requests = [{'cpu': 1}]
    assert is_allocation_feasible(resources, requests) is False

def test_zero_amount_requests():
    # Requests for zero resources should not affect feasibility
    resources = {'cpu': 2}
    requests = [{'cpu': 0}, {'cpu': 0}]
    assert is_allocation_feasible(resources, requests) is True

def test_negative_request_amount():
    # Negative request amounts should be handled (here, treat as infeasible)
    resources = {'cpu': 5}
    requests = [{'cpu': -1}]
    assert is_allocation_feasible(resources, requests) is True  # Acceptable if negative means "give back"

def test_float_resource_and_request():
    # Test with float values for resources and requests
    resources = {'cpu': 5.5}
    requests = [{'cpu': 2.2}, {'cpu': 3.3}]
    assert is_allocation_feasible(resources, requests) is True"

Prompt 6: "Which edge cases are still missing from the testing"
LLM Response 6: "Here are some edge cases still missing from your current tests:

Request for a resource with amount exactly equal to capacity

Ensures allocation is feasible when demand matches capacity exactly.
Multiple resources, some not requested at all

Checks that unused resources do not affect feasibility.
Request with extra keys (resources) not in the available resources

Already partially tested, but could be more explicit for multiple unknown resources.
Large number of requests (stress test)

Checks performance and correctness with many requests."

Prompt for Lab 6:

Prompt 1: "A new requirement has been added. "At least one resource must remain unallocated after assignment" What update needs to be made to the code?"
LLM Response 1: "To satisfy the new requirement—at least one resource must remain unallocated after assignment—you need to check after processing all requests that at least one resource in available has a value greater than zero."

Prompt 2: "Update the test cases to test for this new requirement."
LLM Response 2: 
"def test_basic_feasible_single_resource():
    # Now infeasible if all resources are exactly consumed
    resources = {'cpu': 10}
    requests = [{'cpu': 3}, {'cpu': 4}, {'cpu': 3}]
    assert is_allocation_feasible(resources, requests) is False  # All cpu used, violates new requirement

def test_multi_resource_infeasible_one_overloaded():
    resources = {'cpu': 8, 'mem': 30}
    requests = [{'cpu': 2, 'mem': 8}, {'cpu': 3, 'mem': 10}, {'cpu': 3, 'mem': 14}]
    assert is_allocation_feasible(resources, requests) is False

def test_missing_resource_in_availability():
    resources = {'cpu': 10}
    requests = [{'cpu': 2}, {'gpu': 1}]
    assert is_allocation_feasible(resources, requests) is False

def test_non_dict_request_raises():
    resources = {'cpu': 5}
    requests = [{'cpu': 2}, ['mem', 1]]
    with pytest.raises(ValueError):
        is_allocation_feasible(resources, requests)

def test_empty_requests():
    # No requests: at least one resource remains unallocated
    resources = {'cpu': 5, 'mem': 10}
    requests = []
    assert is_allocation_feasible(resources, requests) is True

def test_empty_resources_with_requests():
    resources = {}
    requests = [{'cpu': 1}]
    assert is_allocation_feasible(resources, requests) is False

def test_zero_amount_requests():
    # All resources remain unallocated
    resources = {'cpu': 2}
    requests = [{'cpu': 0}, {'cpu': 0}]
    assert is_allocation_feasible(resources, requests) is True

def test_negative_request_amount():
    resources = {'cpu': 5}
    requests = [{'cpu': -1}]
    assert is_allocation_feasible(resources, requests) is True

def test_float_resource_and_request():
    # All resources exactly consumed: infeasible under new requirement
    resources = {'cpu': 5.5}
    requests = [{'cpu': 2.2}, {'cpu': 3.3}]
    assert is_allocation_feasible(resources, requests) is False

def test_at_least_one_resource_left():
    # Only one resource is left after allocation
    resources = {'cpu': 5, 'mem': 10}
    requests = [{'cpu': 5}]
    assert is_allocation_feasible(resources, requests) is True  # mem remains

def test_no_resource_left():
    # All resources exactly consumed
    resources = {'cpu': 5, 'mem': 10}
    requests = [{'cpu': 5, 'mem': 10}]
    assert is_allocation_feasible(resources, requests) is False

def test_one_resource_zeroed_others_left():
    # One resource zeroed, others remain
    resources = {'cpu': 5, 'mem': 10}
    requests = [{'cpu': 5}]
    assert is_allocation_feasible(resources, requests) is True  # mem remains

def test_all_resources_zeroed():
    resources = {'cpu': 2, 'mem': 3}
    requests = [{'cpu': 2, 'mem': 3}]
    assert is_allocation_feasible(resources, requests) is False"

Prompt 3: ""An allocation that satisfies all requests but consumes all available resource is no longer valid." what about this? Does this change the test?"
LLM Response 3:
"If all available resources are fully consumed (i.e., every resource is reduced to zero after allocation), the allocation is not valid under the new requirement.

Restated:

If, after fulfilling all requests, every resource has exactly zero left, the function must return False.
If at least one resource has a positive amount left, the function can return True.
Examples:

resources = {'cpu': 5, 'mem': 10}
requests = [{'cpu': 5, 'mem': 10}]
→ All resources consumed, so return False.

resources = {'cpu': 5, 'mem': 10}
requests = [{'cpu': 5}]
→ cpu is zero, but mem is still 10, so return True."

Prompt 4: "for resource, amount in available.items():
    if not (amount >= 0):
        return False
        Does this change to the code satisfy the requirement?"
LLM Response 4:
"No, that code does not fully satisfy the requirement.

What your code does:
for resource, amount in available.items():
    if not (amount >= 0):
        return False
This only checks that no resource is negative after allocation.
It does not check if at least one resource remains positive (unallocated).
This only checks that no resource is negative after allocation.
It does not check if at least one resource remains positive (unallocated).
What you need:
You must check that at least one resource has a positive amount left after allocation.

Correct code:
# After processing all requests
if not any(amount > 0 for amount in available.values()):
    return False
return True
"

Prompt 1:
LLM Response 1:

Prompt 1:
LLM Response 1:

Prompt 1:
LLM Response 1:

Prompt 1:
LLM Response 1: